# Leetcode 72 - Edit Distance
典型的动态规划。

## Algorithm
关键在于找到动态规划的递推式。假设我们有两个很长的字符串`str1,str2`，长度分别为`n1,n2`，我们可以想到几个方案：

- `str1`删除最后一个字符，`str1.substr(0, n1 - 1)`用`m1`步编辑到`str2`；
- `str1`用`m2`步编辑到`str2.substr(0, n2 - 1)`，然后添加`str2`的最后一个字符`str2[n2 - 1]`；
- `str1.substr(0, n1 - 1)`用`m3`步编辑到`str2.substr(0, n2 - 1)`，然后有如下情况
    - `str1[n1 - 1]`和`str2[n2 - 1]`相同，那么编辑完成了；
    - `str1[n1 - 1]`和`str2[n2 - 1]`相同，那么把`str1`的最后一个字符做一个替换。

上面三种取最小的一种就是我们需要的结果。但是这种递归特别麻烦，如果你写递归，结果估计是超时。解决办法是矩阵提前计算好所有的值，取最右下角的即可。这个矩阵`A(i, j)`是什么意思呢，就是指`str1`的前`i`个字符组成的子串到`str2`的前`j`个字符组成的子串的编辑距离，这个矩阵的大小是`(n1+1)*(n2+1)`。

举个例子，假设我们的两个字符串是`"dinirazine","acetylp"`，这个`A`矩阵应该是这个样子的：

|dist|-|a|ac|ace|acet|acety|acetyl|acetylp|
| :--- | :---: | --- | --- | --- | --- | --- | :---: | :---: |
|**-**|1|2|3|4|5|6|7|
|**d**|1|1|2|3|4|5|6|7|
|**di**|2|2|2|3|4|5|6|7|
|**din**|3|3|3|3|4|5|6|7|
|**dini**|4|4|4|4|4|5|6|7|
|**dinir**|5|5|5|5|5|5|6|7|
|**dinira**|6|5|6|6|6|6|6|7|
|**diniraz**|7|6|6|7|7|7|7|7|
|**dinirazi**|8|7|7|7|8|8|8|8|
|**dinirazin**|9|8|8|8|8|9|9|9|
|**dinirazine**|10|9|9|8|9|9|10|10|

最初始只有最上面一行和最左边一列，不停利用上面的规则进行填充，把这个矩阵填满，然后右下角的10就是需要求的编辑距离。这一段简单的程序可以击败大多数的其他Submission，但还可以做改进。
